<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VPS Github</title>
    <link href="icondark.svg" rel="icon" type="image/svg" media="(prefers-color-scheme: dark)">
    <link href="iconlight.svg" rel="icon" type="image/svg" media="(prefers-color-scheme: light)">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://soctrungkien.github.io/1HzH9Axaj/Fira_Code_v6.2/fira_code.css" rel="stylesheet">
    <script src="style.js"></script>
    <script src="https://tweetnacl.js.org/nacl.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweetnacl-sealedbox-js@1.2.0/sealedbox.web.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/tweetnacl-util/nacl-util.min.js"></script>
</head>
<body>
    <a id="hello" style="display: none;">GOODBYE WORLD!</a>
    <div class="container" style="display: block;">
        <div class="header">
            <div class="logo">
                <i class="fas fa-server"></i>
            </div>
            <h1 class="title">VPS Github</h1>
        </div>

        <!-- Create VPS Tab -->
        <div id="create-tab" class="tab-content active">
            <form id="vpsForm">
                <div class="form-group">
                    <label class="form-label">
                        <i class="fab fa-github"></i> GitHub Token
                    </label>
                    <input 
                        type="password" 
                        id="githubToken" 
                        class="form-input" 
                        placeholder="ghp_xxxxxxxxxxxxxxxxxxxx"
                        required
                    >
                </div>
                
                <button type="submit" class="create-btn" id="createBtn">
                    <i class="fas fa-rocket"></i> T·∫°o VPS Windows
                </button>
                

            </form>

            <div id="statusMessage"></div>
            <div id="vpsinfo"></div>

            <div class="feature-list">
                <div class="feature-item">
                    <i class="fas fa-desktop"></i>
                    Windows Server 2025 v·ªõi GUI ƒë·∫ßy ƒë·ªß
                </div>
                <div class="feature-item">
                    <i class="fas fa-clock"></i>
                    Th·ªùi gian ho·∫°t ƒë·ªông: 5.5 gi·ªù
                </div>
                <div class="feature-item">
                    <i class="fas fa-shield-alt"></i>
                    K·∫øt n·ªëi qua RDP (Remote Desktop Protocol)
                </div>
            </div>
        </div>
    </div>
<script>
if (typeof window !== "undefined") window.sealedbox = sealedbox;
console.log("üîπ nacl:", typeof nacl !== "undefined");
console.log("üîπ sealedbox:", typeof sealedbox !== "undefined");

const pub = nacl.box.keyPair().publicKey;
const msg = new TextEncoder().encode("hello github!");
const sealed = sealedbox.seal(msg, pub);
console.log("‚úÖ sealedbox ho·∫°t ƒë·ªông!", sealed.length);
// make m·ªôt √≠t ny ch√°t g·ªù b√™ t∆°
(async function(){
  // =========== helper UI ===========
  function showStatus(message, type='info'){
    const statusDiv = document.getElementById('statusMessage');
    if(!statusDiv) return console.log(type, message);
    const icon = type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle';
    statusDiv.innerHTML = `<div class="status-message status-${type}">
      <i class="fas fa-${icon}"></i>
      <div style="flex:1">${message}</div>
    </div>`;
  }
  function showVpsinfo(url, pass, username){
    const infoDiv = document.getElementById('vpsinfo');
    if(!infoDiv) return console.log('VPS', url, pass, username);
    infoDiv.innerHTML = `<div class="vpsinfo">
      <div class="vps-link-title"><i class="fas fa-external-link-alt"></i> VPS c·ªßa b·∫°n ƒë√£ s·∫µn s√†ng!</div>
      IP: <a href="${url}" target="_blank" class="vps-link-url">${url}</a>
      <div style="margin-top: 12px; font-size: 13px; color: #718096;">
        <i class="fas fa-key"></i> M·∫≠t kh·∫©u RDP: <strong>${username}@${pass}</strong>
      </div>
    </div>`;
  }

  function b64EncodeUnicode(str) {
    return btoa(unescape(encodeURIComponent(str || "")));
  }

async function ghFetch(arg1, arg2, arg3) {
  let endpoint, token, options = arg3 || {};

  const isProbablyToken = (s) =>
    typeof s === "string" &&
    !!s &&
    (
      s.startsWith("ghp_") || s.startsWith("gho_") || s.startsWith("ghu_") ||
      s.startsWith("ghs_") || s.startsWith("github_pat_") ||
      s.startsWith("glpat_") || s.startsWith("ghr_") || s.startsWith("github_")
    );

  // üß© Ph√¢n t√≠ch tham s·ªë
  if (typeof arg1 === "string" && (arg1.startsWith("http") || arg1.startsWith("/"))) {
    endpoint = arg1;
    token = arg2;
  } else if (isProbablyToken(arg1)) {
    token = arg1;
    endpoint = arg2;
  } else {
    endpoint = arg1;
    token = arg2;
  }

  if (!endpoint) throw new Error("ghFetch: missing endpoint");

  // üß© Chu·∫©n h√≥a endpoint
  endpoint = endpoint.trim();
  if (!endpoint.startsWith("http")) {
    endpoint = `https://api.github.com${endpoint.startsWith("/") ? "" : "/"}${endpoint}`;
  }
  endpoint = endpoint.replace(/([^:]\/)\/+/g, "$1"); // tr√°nh l·ªói double slash

  // üß© L√†m s·∫°ch token
  if (typeof token === "string") {
    token = token.trim().replace(/\s+/g, "");
  }

  // üß© Chu·∫©n header
  const headers = {
    Accept: "application/vnd.github+json",
    ...(options.headers || {}),
  };

  if (token) {
    headers.Authorization = token.startsWith("ghp_") || token.startsWith("github_") || token.startsWith("glpat_")
      ? `token ${token}`
      : `Bearer ${token}`;
  }

  // ‚úÖ Gi·ªõi h·∫°n header v·ªÅ ASCII ƒë·ªÉ tr√°nh l·ªói encoding
  for (const key in headers) {
    headers[key] = String(headers[key]).replace(/[^\x00-\x7F]/g, "");
  }

  // üß© Fetch c√≥ retry nh·∫π
  let res, text, data;
  try {
    res = await fetch(endpoint, { ...options, headers });
    text = await res.text();
  } catch (err) {
    console.error(`‚ö†Ô∏è Network error when fetching ${endpoint}:`, err);
    return { ok: false, status: 0, statusText: "NETWORK_ERROR", data: err, headers: {} };
  }

  try {
    data = JSON.parse(text);
  } catch {
    data = text;
  }

  // üß© Auto log l·ªói GitHub
  if (!res.ok) {
    console.warn(`‚ùå GitHub API error ${res.status}:`, data?.message || data);
  }

  return { ok: res.ok, status: res.status, statusText: res.statusText, data, headers: res.headers };
}

  // =========== detect token ===========
  async function detectToken(token){
    try{
      const r = await ghFetch('/user', token);
      const headers = r.headers instanceof Headers ? r.headers : new Headers();
      const scopes = headers.get('x-oauth-scopes') || headers.get('X-Oauth-Scopes') || '';
      if (r.ok && r.data) {
        return { type: 'user_token_or_PAT', user: r.data.login, scopes: scopes.split(',').map(s=>s.trim()).filter(Boolean), raw: r };
      }
      if (r.status === 401) return { type: 'invalid', status: 401, raw: r };
      // fallback: check rate limit
      const rl = await ghFetch('/rate_limit', token);
      return { type: 'unknown', status: r.status, root: r.data, rate: rl.data, raw: r };
    }catch(e){ return { type:'error', message: e.message }; }
  }

  // =========== create repo if not exists ===========
  async function createRepoIfNotExists(token, name){
    const body = { name, private: false, auto_init: true, description: "run-vps repo created by script" };
    const r = await ghFetch('/user/repos', token, { method: 'POST', body: JSON.stringify(body), headers: { 'Content-Type':'application/json' }});
    if (r.ok) return r.data;
    if (r.status === 422) {
      // repo exists (maybe), fetch repo
      const u = await ghFetch('/user', token);
      if (!u.ok) throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c user ƒë·ªÉ x√°c ƒë·ªãnh owner.');
      const owner = u.data.login;
      const fetchRepo = await ghFetch(`/repos/${owner}/${name}`, token);
      if (fetchRepo.ok) return fetchRepo.data;
      throw new Error('Repo c√≥ v·∫ª t·ªìn t·∫°i nh∆∞ng kh√¥ng truy xu·∫•t ƒë∆∞·ª£c: ' + JSON.stringify(r.data));
    }
    throw new Error(`T·∫°o repo l·ªói: ${r.status} ${JSON.stringify(r.data)}`);
  }

  // =========== create or update file ===========
  async function createOrUpdateFile(token, owner, repo, path, contentText, commitMessage = 'Add '+path){
    // GET existing
    const get = await ghFetch(`/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`, token);
    let sha = null;
    if (get.ok && get.data && get.data.sha) sha = get.data.sha;
    const body = { message: commitMessage, content: b64EncodeUnicode(contentText) };
    if (sha) body.sha = sha;
    const put = await ghFetch(`/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`, token, { method: 'PUT', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(body) });
    if (!put.ok) throw new Error(`T·∫°o/c·∫≠p nh·∫≠t file ${path} l·ªói: ${put.status} ${JSON.stringify(put.data)}`);
    return put.data;
  }

    
async function createOrUpdateSecret(token, owner, repo, secretName, secretValue) {
  token = String(token).trim();

  // üîπ L·∫•y public key c·ªßa repo
  const pk = await ghFetch(`/repos/${owner}/${repo}/actions/secrets/public-key`, token);
  if (!pk.ok) throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c public key c·ªßa repo: ' + JSON.stringify(pk.data));

  // üîπ M√£ ho√° secret b·∫±ng tweetnacl sealedbox
  const publicKey = nacl.util.decodeBase64(pk.data.key);
  const message = new TextEncoder().encode(String(secretValue));
  const sealed = sealedbox.seal(message, publicKey);
  const encrypted_value = nacl.util.encodeBase64(sealed);

  // üîπ G·ª≠i secret ƒë√£ m√£ ho√° l√™n GitHub
  const put = await ghFetch(`/repos/${owner}/${repo}/actions/secrets/${encodeURIComponent(secretName)}`, token, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ encrypted_value, key_id: pk.data.key_id })
  });

  if (!put.ok) throw new Error('T·∫°o secret l·ªói: ' + JSON.stringify(put.data));
  return true;
}

  // =========== ensure permissions block (simple) ===========
  function ensurePermissionsAndDispatch(workflowText){
    if (!workflowText || typeof workflowText !== 'string') return workflowText || '';
    // quick check: if contains "permissions:" and both contents/actions write, leave
    if (/permissions:\s*([\s\S]*?)\n(?=\S)/m.test(workflowText)) {
      if (/contents:\s*write/.test(workflowText) && /actions:\s*write/.test(workflowText)) return workflowText;
    }
    const permBlock = `permissions:\n  contents: write\n  actions: write\n\n`;
    return permBlock + workflowText;
  }

  // =========== fetch external workflow with default fallback ===========
  async function fetchWorkflowOrDefault(url, defaultContent){
    if (!url) return defaultContent;
    try{
      const r = await fetch(url, {cache:'no-cache'});
      if (!r.ok) throw new Error('Fetch fail '+r.status);
      const txt = await r.text();
      if (!txt || txt.trim().length === 0) throw new Error('Empty content');
      return txt;
    }catch(e){
      console.warn('Kh√¥ng l·∫•y ƒë∆∞·ª£c t·ª´ URL, d√πng n·ªôi dung m·∫∑c ƒë·ªãnh.', e);
      return defaultContent;
    }
  }

  // =========== trigger workflow dispatch ===========
  async function triggerWorkflow(token, owner, repo, workflowFileName, ref='main', inputs={}){
    // try direct path first
    const r = await ghFetch(`/repos/${owner}/${repo}/actions/workflows/${encodeURIComponent(workflowFileName)}/dispatches`, token, {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify({ ref, inputs })
    });
    if (r.status === 204 || (r.ok && r.status === 204)) return true;
    // fallback: list workflows and match by path or name
    const list = await ghFetch(`/repos/${owner}/${repo}/actions/workflows`, token);
    if (list.ok && list.data && Array.isArray(list.data.workflows)){
      const wf = list.data.workflows.find(w => (w.path && w.path.endsWith(workflowFileName)) || (w.name && w.name === workflowFileName));
      if (wf){
        const r2 = await ghFetch(`/repos/${owner}/${repo}/actions/workflows/${wf.id}/dispatches`, token, {
          method:'POST',
          headers:{ 'Content-Type':'application/json' },
          body: JSON.stringify({ ref, inputs })
        });
        if (r2.status === 204 || (r2.ok && r2.status === 204)) return true;
      }
    }
    throw new Error('Kh√¥ng th·ªÉ dispatch workflow. Response: ' + JSON.stringify(r.data || r));
  }

  // =========== get username helper ===========
  async function getUserName(token){
    const r = await ghFetch('/user', token);
    if (r.ok && r.data && r.data.login) return r.data.login;
    throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c username: ' + JSON.stringify(r.data));
  }

  // =========== waitForFile ===========
  async function waitForFile(token, owner, repo, path, interval = 5000, timeout = 60000) {
    if (!owner) owner = await getUserName(token);
    const start = Date.now();
    showStatus(`ƒêang ch·ªù file "${path}" trong repo ${owner}/${repo}...`, 'info');

    while (Date.now() - start < timeout) {
      try {
        const headers = { Accept: "application/vnd.github+json" };
        // auth header
        if (token) {
          if (token.startsWith('ghp_') || token.startsWith('github_') || token.startsWith('glpat_')) headers.Authorization = `token ${token}`;
          else headers.Authorization = `Bearer ${token}`;
        }
        const res = await fetch(`https://raw.githubusercontent.com/${owner}/${repo}/main/${encodeURIComponent(path)}`, { method: 'HEAD', headers });
        if (res.ok) {
          console.log(`‚úÖ File ${path} ƒë√£ xu·∫•t hi·ªán trong repo ${repo}!`);
          return true;
        } else if (res.status === 404) {
          console.log(`‚è≥ Ch∆∞a th·∫•y file ${path}, ch·ªù th√™m ${interval/1000}s...`);
          await new Promise(r=>setTimeout(r, interval));
        } else {
          console.warn(`‚ö†Ô∏è API l·ªói ${res.status}: ${res.statusText}`);
          break;
        }
      } catch (e) {
        console.error("üí• L·ªói fetch:", e);
        break;
      }
    }

    console.warn(`‚ùå Qu√° ${timeout/1000}s r·ªìi m√† file ${path} v·∫´n ch∆∞a c√≥.`);
    return false;
  }

  // =========== MAIN listener ===========
  document.getElementById('vpsForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const token = document.getElementById('githubToken').value.trim();
    const createBtn = document.getElementById('createBtn');
    const originalBtnText = createBtn.innerHTML;
    if(!token){ showStatus('Vui l√≤ng nh·∫≠p GitHub Token!', 'error'); return; }

    try{
      createBtn.disabled = true;
      createBtn.innerHTML = '<span class="loading-spinner"></span>ƒêang t·∫°o VPS...';
      showStatus('ƒêang ki·ªÉm tra token...', 'info');

      const det = await detectToken(token);
      console.log('detectToken:', det);
      if (det.type === 'invalid') { showStatus('Token kh√¥ng h·ª£p l·ªá ho·∫∑c h·∫øt h·∫°n (401).', 'error'); throw new Error('Token invalid'); }
      if (det.type === 'error') { showStatus('L·ªói khi ki·ªÉm tra token: '+det.message, 'error'); throw new Error(det.message); }
      showStatus(`Token OK. user=${det.user||'unknown'}, scopes=${(det.scopes||[]).join(', ') || '(unknown)'}`, 'success');

      // get owner (authenticated user)
      const who = await ghFetch('/user', token);
      if (!who.ok) throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c user info: ' + JSON.stringify(who.data));
      const owner = who.data.login;

      showStatus('T·∫°o repo run-vps (public)...', 'info');
      const repoData = await (async ()=>{
        try{
          return await createRepoIfNotExists(token, 'run-vps');
        }catch(err){
          // if err says exists, try fetch
          console.warn('createRepoIfNotExists l·ªói, th·ª≠ fetch tr·ª±c ti·∫øp...', err);
          const r = await ghFetch(`/repos/${owner}/run-vps`, token);
          if (r.ok) return r.data;
          throw err;
        }
      })();
      console.log('repoData', repoData);
      showStatus('Repo ready: ' + (repoData.html_url || 'run-vps'), 'success');

      // random 5-digit
      const randPass = Math.floor(10000 + Math.random()*90000).toString();
      showStatus('T·∫°o secret MY_PASSWORD (ƒëang m√£ ho√°)...', 'info');
      await createOrUpdateSecret(token, owner, 'run-vps', 'MY_PASSWORD', randPass);
      showStatus('Secret MY_PASSWORD ƒë√£ t·∫°o üîê', 'success');

      showStatus('L·∫•y n·ªôi dung workflow t·ª´ URL (ho·∫∑c d√πng m·∫´u)...', 'info');
    const delSource = deleteURL ? deleteURL : 'workflow/2.txt (local)';
    const vpsSource = vpsURL ? vpsURL : 'workflow/1.txt (local)';
    showStatus(`L·∫•y workflow delete t·ª´: ${delSource} ; VPS t·ª´: ${vpsSource}`, 'info');
    const delTxt = ensurePermissionsAndDispatch(await fetchWorkflowOrDefault('workflow/2.txt'));
    const vpsTxt = ensurePermissionsAndDispatch(await fetchWorkflowOrDefault('workflow/1.txt'));

      showStatus('Upload workflow files...', 'info');
      await createOrUpdateFile(token, owner, 'run-vps', '.github/workflows/delete.yml', delTxt, 'Add delete workflow');
      await createOrUpdateFile(token, owner, 'run-vps', '.github/workflows/VPS_github.yml', vpsTxt, 'Add VPS_github workflow');
      showStatus('Workflow uploaded ‚úÖ', 'success');

      // Trigger VPS_github workflow
      showStatus('G·ª≠i request ch·∫°y workflow VPS_github.yml...', 'info');
      await triggerWorkflow(token, owner, 'run-vps', 'VPS_github.yml', 'main', {});
      showStatus('Workflow VPS_github ƒë√£ ƒë∆∞·ª£c dispatch üöÄ', 'success');

      // Ch·ªù file RDP xu·∫•t hi·ªán
      showStatus('ƒêang ch·ªù file RDP xu·∫•t hi·ªán...', 'info');
      const repo = 'run-vps';
      const path = 'rdp-connection.rdp';
      const fileReady = await waitForFile(token, null, repo, path, 7000, 180000);

      if (fileReady) {
        const username = await getUserName(token);
        const rdpUrl = `https://raw.githubusercontent.com/${username}/${repo}/main/${encodeURIComponent(path)}`;
        showVpsinfo(rdpUrl, randPass, username);
        showStatus('VPS ƒë√£ s·∫µn s√†ng üéâ', 'success');
      } else {
        showStatus('Kh√¥ng th·∫•y file RDP sau th·ªùi gian ch·ªù üòî', 'error');
      }

    }catch(err){
      console.error(err);
      showStatus('L·ªói: ' + (err.message || String(err)), 'error');
    }finally{
      createBtn.disabled = false;
      createBtn.innerHTML = originalBtnText;
    }
  });

  // focus input
  try{ document.getElementById('githubToken').focus(); }catch(e){}
})();
</script>
</body>
</html>