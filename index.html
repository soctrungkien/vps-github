<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VPS Github</title>
    <link href="icondark.svg" rel="icon" type="image/svg" media="(prefers-color-scheme: dark)">
    <link href="iconlight.svg" rel="icon" type="image/svg" media="(prefers-color-scheme: light)">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://soctrungkien.github.io/1HzH9Axaj/Fira_Code_v6.2/fira_code.css" rel="stylesheet">
    <script src="style.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/libsodium-wrappers@0.7.13/dist/libsodium-wrappers.js"></script>
</head>
<body>
    <a id="hello" style="display: none;">GOODBYE WORLD!</a>
    <div class="container" style="display: block;">
        <div class="header">
            <div class="logo">
                <i class="fas fa-server"></i>
            </div>
            <h1 class="title">VPS Github</h1>
        </div>

        <!-- Create VPS Tab -->
        <div id="create-tab" class="tab-content active">
            <form id="vpsForm">
                <div class="form-group">
                    <label class="form-label">
                        <i class="fab fa-github"></i> GitHub Token
                    </label>
                    <input 
                        type="password" 
                        id="githubToken" 
                        class="form-input" 
                        placeholder="ghp_xxxxxxxxxxxxxxxxxxxx"
                        required
                    >
                </div>
                
                <button type="submit" class="create-btn" id="createBtn">
                    <i class="fas fa-rocket"></i> T·∫°o VPS Windows
                </button>
                

            </form>

            <div id="statusMessage"></div>
            <div id="vpsinfo"></div>

            <div class="feature-list">
                <div class="feature-item">
                    <i class="fas fa-desktop"></i>
                    Windows Server 2025 v·ªõi GUI ƒë·∫ßy ƒë·ªß
                </div>
                <div class="feature-item">
                    <i class="fas fa-clock"></i>
                    Th·ªùi gian ho·∫°t ƒë·ªông: 5.5 gi·ªù
                </div>
                <div class="feature-item">
                    <i class="fas fa-shield-alt"></i>
                    K·∫øt n·ªëi qua RDP (Remote Desktop Protocol)
                </div>
            </div>
        </div>
    </div>
<script>
// make m·ªôt √≠t ny ch√°t g·ªù b√™ t∆°
(async function(){
  // =========== helper UI ===========
  function showStatus(message, type='info'){
    const statusDiv = document.getElementById('statusMessage');
    if(!statusDiv) return console.log(type, message);
    const icon = type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle';
    statusDiv.innerHTML = `<div class="status-message status-${type}">
      <i class="fas fa-${icon}"></i>
      <div style="flex:1">${message}</div>
    </div>`;
  }
  function showVpsinfo(url, pass, username){
    const infoDiv = document.getElementById('vpsinfo');
    if(!infoDiv) return console.log('VPS', url, pass, username);
    infoDiv.innerHTML = `<div class="vpsinfo">
      <div class="vps-link-title"><i class="fas fa-external-link-alt"></i> VPS c·ªßa b·∫°n ƒë√£ s·∫µn s√†ng!</div>
      IP: <a href="${url}" target="_blank" class="vps-link-url">${url}</a>
      <div style="margin-top: 12px; font-size: 13px; color: #718096;">
        <i class="fas fa-key"></i> M·∫≠t kh·∫©u RDP: <strong>${username}@${pass}</strong>
      </div>
    </div>`;
  }

  function b64EncodeUnicode(str) {
    return btoa(unescape(encodeURIComponent(str || "")));
  }

  // =========== libsodium loader (used for secrets) ===========
    async function loadSodium() {
      try {
        // N·∫øu ƒë√£ load r·ªìi th√¨ b·ªè qua
        if (window.sodium && window.sodium.ready) {
          await window.sodium.ready;
          console.log("‚úÖ Libsodium ƒë√£ s·∫µn s√†ng (cache)!");
          return window.sodium;
        }
    
        console.log("üîπ ƒêang t·∫£i libsodium (non-module build)...");
        await new Promise((resolve, reject) => {
          const script = document.createElement("script");
          script.src = "https://cdn.jsdelivr.net/npm/libsodium-wrappers@0.7.13/dist/libsodium-wrappers.js";
          script.onload = () => resolve();
          script.onerror = (e) => reject(e);
          document.head.appendChild(script);
        });
    
        if (!window.sodium) throw new Error("libsodium kh√¥ng load v√†o window ƒë∆∞·ª£c.");
        await window.sodium.ready;
    
        console.log("‚úÖ Libsodium loaded th√†nh c√¥ng!");
        return window.sodium;
      } catch (err) {
        console.error("‚ùå L·ªói khi load libsodium:", err);
        alert("Kh√¥ng th·ªÉ t·∫£i libsodium. Ki·ªÉm tra m·∫°ng ho·∫∑c th·ª≠ l·∫°i sau.");
        throw err;
      }
    }

  // =========== Robust ghFetch ===========
  /**
   * ghFetch(endpoint, token, options) OR ghFetch(token, endpoint, options)
   * returns { ok, status, statusText, data, headers }
   */
  async function ghFetch(arg1, arg2, arg3){
    let endpoint, token, options;
    options = arg3 || {};

    // decide which arg is endpoint/token
    const isProbablyToken = (s) => typeof s === 'string' && !!s && (
      s.startsWith('ghp_') || s.startsWith('gho_') || s.startsWith('ghu_') || s.startsWith('ghs_') ||
      s.startsWith('github_pat_') || s.startsWith('glpat_') || s.startsWith('ghr_') || s.startsWith('github_')
    );

    if (typeof arg1 === 'string' && (arg1.startsWith('http') || arg1.startsWith('/'))) {
      endpoint = arg1; token = arg2; options = arg3 || {};
    } else if (isProbablyToken(arg1)) {
      token = arg1; endpoint = arg2; options = arg3 || {};
    } else {
      // default: assume arg1 is endpoint
      endpoint = arg1; token = arg2; options = arg3 || {};
    }

    if (!endpoint) throw new Error('ghFetch: missing endpoint');

    if (!endpoint.startsWith('http')) {
      endpoint = `https://api.github.com${endpoint.startsWith('/') ? '' : '/'}${endpoint}`;
    }

    let authHeader;
    if (token) {
      if (token.startsWith('ghp_') || token.startsWith('github_') || token.startsWith('glpat_')) {
        authHeader = `token ${token}`;
      } else {
        authHeader = `Bearer ${token}`;
      }
    }

    const headers = {
      Accept: "application/vnd.github+json",
      ...(options.headers || {})
    };
    if (authHeader) headers.Authorization = authHeader;

    const res = await fetch(endpoint, { ...options, headers });
    const text = await res.text();
    let data;
    try { data = JSON.parse(text); } catch (e) { data = text; }

    return { ok: res.ok, status: res.status, statusText: res.statusText, data, headers: res.headers };
  }

  // =========== detect token ===========
  async function detectToken(token){
    try{
      const r = await ghFetch('/user', token);
      const headers = r.headers instanceof Headers ? r.headers : new Headers();
      const scopes = headers.get('x-oauth-scopes') || headers.get('X-Oauth-Scopes') || '';
      if (r.ok && r.data) {
        return { type: 'user_token_or_PAT', user: r.data.login, scopes: scopes.split(',').map(s=>s.trim()).filter(Boolean), raw: r };
      }
      if (r.status === 401) return { type: 'invalid', status: 401, raw: r };
      // fallback: check rate limit
      const rl = await ghFetch('/rate_limit', token);
      return { type: 'unknown', status: r.status, root: r.data, rate: rl.data, raw: r };
    }catch(e){ return { type:'error', message: e.message }; }
  }

  // =========== create repo if not exists ===========
  async function createRepoIfNotExists(token, name){
    const body = { name, private: false, auto_init: true, description: "run-vps repo created by script" };
    const r = await ghFetch('/user/repos', token, { method: 'POST', body: JSON.stringify(body), headers: { 'Content-Type':'application/json' }});
    if (r.ok) return r.data;
    if (r.status === 422) {
      // repo exists (maybe), fetch repo
      const u = await ghFetch('/user', token);
      if (!u.ok) throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c user ƒë·ªÉ x√°c ƒë·ªãnh owner.');
      const owner = u.data.login;
      const fetchRepo = await ghFetch(`/repos/${owner}/${name}`, token);
      if (fetchRepo.ok) return fetchRepo.data;
      throw new Error('Repo c√≥ v·∫ª t·ªìn t·∫°i nh∆∞ng kh√¥ng truy xu·∫•t ƒë∆∞·ª£c: ' + JSON.stringify(r.data));
    }
    throw new Error(`T·∫°o repo l·ªói: ${r.status} ${JSON.stringify(r.data)}`);
  }

  // =========== create or update file ===========
  async function createOrUpdateFile(token, owner, repo, path, contentText, commitMessage = 'Add '+path){
    // GET existing
    const get = await ghFetch(`/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`, token);
    let sha = null;
    if (get.ok && get.data && get.data.sha) sha = get.data.sha;
    const body = { message: commitMessage, content: b64EncodeUnicode(contentText) };
    if (sha) body.sha = sha;
    const put = await ghFetch(`/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`, token, { method: 'PUT', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(body) });
    if (!put.ok) throw new Error(`T·∫°o/c·∫≠p nh·∫≠t file ${path} l·ªói: ${put.status} ${JSON.stringify(put.data)}`);
    return put.data;
  }

    
    async function createOrUpdateSecret(token, owner, repo, secretName, secretValue) {
      token = String(token).trim(); // üîπ tr√°nh k√Ω t·ª± l·∫°
    
      const pk = await ghFetch(`/repos/${owner}/${repo}/actions/secrets/public-key`, token);
      if (!pk.ok) throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c public key c·ªßa repo: ' + JSON.stringify(pk.data));
    
      const sodium = await loadSodium();
    
      const bpub = sodium.from_base64(pk.data.key, sodium.base64_variants.ORIGINAL);
      const bsec = sodium.from_string(String(secretValue));
      const sealed = sodium.crypto_box_seal(bsec, bpub);
      const encrypted_value = sodium.to_base64(sealed, sodium.base64_variants.ORIGINAL);
    
      const put = await ghFetch(`/repos/${owner}/${repo}/actions/secrets/${encodeURIComponent(secretName)}`, token, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ encrypted_value, key_id: pk.data.key_id })
      });
    
      if (!put.ok) throw new Error('T·∫°o secret l·ªói: ' + JSON.stringify(put.data));
      return true;
    }

  // =========== ensure permissions block (simple) ===========
  function ensurePermissionsAndDispatch(workflowText){
    if (!workflowText || typeof workflowText !== 'string') return workflowText || '';
    // quick check: if contains "permissions:" and both contents/actions write, leave
    if (/permissions:\s*([\s\S]*?)\n(?=\S)/m.test(workflowText)) {
      if (/contents:\s*write/.test(workflowText) && /actions:\s*write/.test(workflowText)) return workflowText;
    }
    const permBlock = `permissions:\n  contents: write\n  actions: write\n\n`;
    return permBlock + workflowText;
  }

  // =========== fetch external workflow with default fallback ===========
  async function fetchWorkflowOrDefault(url, defaultContent){
    if (!url) return defaultContent;
    try{
      const r = await fetch(url, {cache:'no-cache'});
      if (!r.ok) throw new Error('Fetch fail '+r.status);
      const txt = await r.text();
      if (!txt || txt.trim().length === 0) throw new Error('Empty content');
      return txt;
    }catch(e){
      console.warn('Kh√¥ng l·∫•y ƒë∆∞·ª£c t·ª´ URL, d√πng n·ªôi dung m·∫∑c ƒë·ªãnh.', e);
      return defaultContent;
    }
  }

  // =========== trigger workflow dispatch ===========
  async function triggerWorkflow(token, owner, repo, workflowFileName, ref='main', inputs={}){
    // try direct path first
    const r = await ghFetch(`/repos/${owner}/${repo}/actions/workflows/${encodeURIComponent(workflowFileName)}/dispatches`, token, {
      method: 'POST',
      headers: { 'Content-Type':'application/json' },
      body: JSON.stringify({ ref, inputs })
    });
    if (r.status === 204 || (r.ok && r.status === 204)) return true;
    // fallback: list workflows and match by path or name
    const list = await ghFetch(`/repos/${owner}/${repo}/actions/workflows`, token);
    if (list.ok && list.data && Array.isArray(list.data.workflows)){
      const wf = list.data.workflows.find(w => (w.path && w.path.endsWith(workflowFileName)) || (w.name && w.name === workflowFileName));
      if (wf){
        const r2 = await ghFetch(`/repos/${owner}/${repo}/actions/workflows/${wf.id}/dispatches`, token, {
          method:'POST',
          headers:{ 'Content-Type':'application/json' },
          body: JSON.stringify({ ref, inputs })
        });
        if (r2.status === 204 || (r2.ok && r2.status === 204)) return true;
      }
    }
    throw new Error('Kh√¥ng th·ªÉ dispatch workflow. Response: ' + JSON.stringify(r.data || r));
  }

  // =========== get username helper ===========
  async function getUserName(token){
    const r = await ghFetch('/user', token);
    if (r.ok && r.data && r.data.login) return r.data.login;
    throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c username: ' + JSON.stringify(r.data));
  }

  // =========== waitForFile ===========
  async function waitForFile(token, owner, repo, path, interval = 5000, timeout = 60000) {
    if (!owner) owner = await getUserName(token);
    const start = Date.now();
    showStatus(`ƒêang ch·ªù file "${path}" trong repo ${owner}/${repo}...`, 'info');

    while (Date.now() - start < timeout) {
      try {
        const headers = { Accept: "application/vnd.github+json" };
        // auth header
        if (token) {
          if (token.startsWith('ghp_') || token.startsWith('github_') || token.startsWith('glpat_')) headers.Authorization = `token ${token}`;
          else headers.Authorization = `Bearer ${token}`;
        }
        const res = await fetch(`https://raw.githubusercontent.com/${owner}/${repo}/main/${encodeURIComponent(path)}`, { method: 'HEAD', headers });
        if (res.ok) {
          console.log(`‚úÖ File ${path} ƒë√£ xu·∫•t hi·ªán trong repo ${repo}!`);
          return true;
        } else if (res.status === 404) {
          console.log(`‚è≥ Ch∆∞a th·∫•y file ${path}, ch·ªù th√™m ${interval/1000}s...`);
          await new Promise(r=>setTimeout(r, interval));
        } else {
          console.warn(`‚ö†Ô∏è API l·ªói ${res.status}: ${res.statusText}`);
          break;
        }
      } catch (e) {
        console.error("üí• L·ªói fetch:", e);
        break;
      }
    }

    console.warn(`‚ùå Qu√° ${timeout/1000}s r·ªìi m√† file ${path} v·∫´n ch∆∞a c√≥.`);
    return false;
  }

  // =========== MAIN listener ===========
  document.getElementById('vpsForm').addEventListener('submit', async (e) => {
    e.preventDefault();
    const token = document.getElementById('githubToken').value.trim();
    const createBtn = document.getElementById('createBtn');
    const originalBtnText = createBtn.innerHTML;
    if(!token){ showStatus('Vui l√≤ng nh·∫≠p GitHub Token!', 'error'); return; }

    try{
      createBtn.disabled = true;
      createBtn.innerHTML = '<span class="loading-spinner"></span>ƒêang t·∫°o VPS...';
      showStatus('ƒêang ki·ªÉm tra token...', 'info');

      const det = await detectToken(token);
      console.log('detectToken:', det);
      if (det.type === 'invalid') { showStatus('Token kh√¥ng h·ª£p l·ªá ho·∫∑c h·∫øt h·∫°n (401).', 'error'); throw new Error('Token invalid'); }
      if (det.type === 'error') { showStatus('L·ªói khi ki·ªÉm tra token: '+det.message, 'error'); throw new Error(det.message); }
      showStatus(`Token OK. user=${det.user||'unknown'}, scopes=${(det.scopes||[]).join(', ') || '(unknown)'}`, 'success');

      // get owner (authenticated user)
      const who = await ghFetch('/user', token);
      if (!who.ok) throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c user info: ' + JSON.stringify(who.data));
      const owner = who.data.login;

      showStatus('T·∫°o repo run-vps (public)...', 'info');
      const repoData = await (async ()=>{
        try{
          return await createRepoIfNotExists(token, 'run-vps');
        }catch(err){
          // if err says exists, try fetch
          console.warn('createRepoIfNotExists l·ªói, th·ª≠ fetch tr·ª±c ti·∫øp...', err);
          const r = await ghFetch(`/repos/${owner}/run-vps`, token);
          if (r.ok) return r.data;
          throw err;
        }
      })();
      console.log('repoData', repoData);
      showStatus('Repo ready: ' + (repoData.html_url || 'run-vps'), 'success');

      // random 5-digit
      const randPass = Math.floor(10000 + Math.random()*90000).toString();
      showStatus('T·∫°o secret MY_PASSWORD (ƒëang m√£ ho√°)...', 'info');
      await createOrUpdateSecret(token, owner, 'run-vps', 'MY_PASSWORD', randPass);
      showStatus('Secret MY_PASSWORD ƒë√£ t·∫°o üîê', 'success');

      showStatus('L·∫•y n·ªôi dung workflow t·ª´ URL (ho·∫∑c d√πng m·∫´u)...', 'info');
    const delSource = deleteURL ? deleteURL : 'workflow/2.txt (local)';
    const vpsSource = vpsURL ? vpsURL : 'workflow/1.txt (local)';
    showStatus(`L·∫•y workflow delete t·ª´: ${delSource} ; VPS t·ª´: ${vpsSource}`, 'info');
    const delTxt = ensurePermissionsAndDispatch(await fetchWorkflowOrDefault('workflow/2.txt'));
    const vpsTxt = ensurePermissionsAndDispatch(await fetchWorkflowOrDefault('workflow/1.txt'));

      showStatus('Upload workflow files...', 'info');
      await createOrUpdateFile(token, owner, 'run-vps', '.github/workflows/delete.yml', delTxt, 'Add delete workflow');
      await createOrUpdateFile(token, owner, 'run-vps', '.github/workflows/VPS_github.yml', vpsTxt, 'Add VPS_github workflow');
      showStatus('Workflow uploaded ‚úÖ', 'success');

      // Trigger VPS_github workflow
      showStatus('G·ª≠i request ch·∫°y workflow VPS_github.yml...', 'info');
      await triggerWorkflow(token, owner, 'run-vps', 'VPS_github.yml', 'main', {});
      showStatus('Workflow VPS_github ƒë√£ ƒë∆∞·ª£c dispatch üöÄ', 'success');

      // Ch·ªù file RDP xu·∫•t hi·ªán
      showStatus('ƒêang ch·ªù file RDP xu·∫•t hi·ªán...', 'info');
      const repo = 'run-vps';
      const path = 'rdp-connection.rdp';
      const fileReady = await waitForFile(token, null, repo, path, 7000, 180000);

      if (fileReady) {
        const username = await getUserName(token);
        const rdpUrl = `https://raw.githubusercontent.com/${username}/${repo}/main/${encodeURIComponent(path)}`;
        showVpsinfo(rdpUrl, randPass, username);
        showStatus('VPS ƒë√£ s·∫µn s√†ng üéâ', 'success');
      } else {
        showStatus('Kh√¥ng th·∫•y file RDP sau th·ªùi gian ch·ªù üòî', 'error');
      }

    }catch(err){
      console.error(err);
      showStatus('L·ªói: ' + (err.message || String(err)), 'error');
    }finally{
      createBtn.disabled = false;
      createBtn.innerHTML = originalBtnText;
    }
  });

  // focus input
  try{ document.getElementById('githubToken').focus(); }catch(e){}
})();
</script>
</body>
</html>