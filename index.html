<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VPS Github</title>
    <link href="icondark.svg" rel="icon" type="image/svg" media="(prefers-color-scheme: dark)">
    <link href="iconlight.svg" rel="icon" type="image/svg" media="(prefers-color-scheme: light)">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <link href="https://soctrungkien.github.io/1HzH9Axaj/Fira_Code_v6.2/fira_code.css" rel="stylesheet">
    <script src="style.js"></script>
</head>
<body>
    <a id="hello" style="display: none;">GOODBYE WORLD!</a>
    <div class="container" style="display: block;">
        <div class="header">
            <div class="logo">
                <i class="fas fa-server"></i>
            </div>
            <h1 class="title">VPS Github</h1>
        </div>

        <!-- Create VPS Tab -->
        <div id="create-tab" class="tab-content active">
            <form id="vpsForm">
                <div class="form-group">
                    <label class="form-label">
                        <i class="fab fa-github"></i> GitHub Token
                    </label>
                    <input 
                        type="password" 
                        id="githubToken" 
                        class="form-input" 
                        placeholder="ghp_xxxxxxxxxxxxxxxxxxxx"
                        required
                    >
                </div>
                
                <button type="submit" class="create-btn" id="createBtn">
                    <i class="fas fa-rocket"></i> T·∫°o VPS Windows
                </button>
                

            </form>

            <div id="statusMessage"></div>
            <div id="vpsinfo"></div>

            <div class="feature-list">
                <div class="feature-item">
                    <i class="fas fa-desktop"></i>
                    Windows Server 2025 v·ªõi GUI ƒë·∫ßy ƒë·ªß
                </div>
                <div class="feature-item">
                    <i class="fas fa-clock"></i>
                    Th·ªùi gian ho·∫°t ƒë·ªông: 5.5 gi·ªù
                </div>
                <div class="feature-item">
                    <i class="fas fa-shield-alt"></i>
                    K·∫øt n·ªëi qua RDP (Remote Desktop Protocol)
                </div>
            </div>
        </div>
    </div>
    <script>
    // make m·ªôt √≠t ny ch√°t g·ªù b√™ t∆°
    (async function(){
      // load libsodium if not loaded
      async function loadSodium(){
        if (window.sodium && window.sodium.ready) return window.sodium.ready;
        if (!document.querySelector('script[data-sodium]')) {
          const s = document.createElement('script');
          s.src = "https://cdn.jsdelivr.net/npm/libsodium-wrappers@0.7.10/dist/modules/libsodium-wrappers.js";
          s.setAttribute('data-sodium','1');
          document.head.appendChild(s);
        }
        // wait for sodium
        const check = () => new Promise((res)=>{ 
          const intr = setInterval(()=>{ if(window.sodium && window.sodium.ready){ clearInterval(intr); res(); } }, 100);
          // timeout after 15s
          setTimeout(()=>{ clearInterval(intr); res(); }, 15000);
        });
        await check();
        if (!window.sodium || !window.sodium.ready) throw new Error('libsodium load failed. Ki·ªÉm tra network.');
        await window.sodium.ready;
        return window.sodium;
      }
    
      // helper UI
      function showStatus(message, type='info'){
        const statusDiv = document.getElementById('statusMessage');
        if(!statusDiv) return console.log(type, message);
        statusDiv.innerHTML = `<div class="status-message status-${type}">
          <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'error' ? 'exclamation-circle' : 'info-circle'}"> </i>
          ${message}
        </div>`;
      }
      function showVpsinfo(url, pass, username){
        const infoDiv = document.getElementById('vpsinfo');
        if(!infoDiv) return console.log('VPS', url, pass, username);
        infoDiv.innerHTML = `<div class="vpsinfo">
          <div class="vps-link-title"><i class="fas fa-external-link-alt"></i> VPS c·ªßa b·∫°n ƒë√£ s·∫µn s√†ng!</div>
          IP: <a href="${url}" target="_blank" class="vps-link-url">${url}</a>
          <div style="margin-top: 12px; font-size: 13px; color: #718096;">
            <i class="fas fa-key"></i> M·∫≠t kh·∫©u RDP: <strong>${username}@${pass}</strong>
          </div>
        </div>`;
      }
    
      // small util
      function b64EncodeUnicode(str) {
        return btoa(unescape(encodeURIComponent(str || "")));
      }
    

        function getAuthHeader(token) {
          if (token.startsWith("ghp_") || token.startsWith("gho_") || token.startsWith("ghu_") || token.startsWith("ghs_")) {
            return { Authorization: `token ${token}` }; // PAT classic ho·∫∑c fine-grained
          } else if (token.startsWith("github_pat_")) {
            return { Authorization: `Bearer ${token}` }; // Fine-grained m·ªõi
          } else if (token.startsWith("ghr_")) {
            return { Authorization: `Bearer ${token}` }; // GitHub App installation token
          } else {
            return { Authorization: `Bearer ${token}` }; // fallback m·∫∑c ƒë·ªãnh
          }
        }

      // Generic GitHub fetch wrapper
async function ghFetch(arg1, arg2, arg3 = {}) {
  let endpoint, token, options;

  // üëá T·ª± x√°c ƒë·ªãnh tham s·ªë n√†o l√† token, tham s·ªë n√†o l√† endpoint
  if (typeof arg1 === "string" && arg1.startsWith("ghp_") || arg1.startsWith("github_") || arg1.startsWith("glpat_")) {
    token = arg1;
    endpoint = arg2;
    options = arg3;
  } else {
    endpoint = arg1;
    token = arg2;
    options = arg3;
  }

  if (!endpoint.startsWith("http")) endpoint = `https://api.github.com${endpoint.startsWith("/") ? "" : "/"}${endpoint}`;

  // üëá Auto x√°c ƒë·ªãnh lo·∫°i token ƒë·ªÉ set header ph√π h·ª£p
  let authHeader;
  if (token?.startsWith("ghp_") || token?.startsWith("github_")) {
    authHeader = `token ${token}`;
  } else if (token?.startsWith("gho_") || token?.startsWith("ghu_") || token?.startsWith("ghs_")) {
    authHeader = `Bearer ${token}`;
  } else {
    authHeader = token ? `Bearer ${token}` : undefined;
  }

  const headers = {
    Accept: "application/vnd.github+json",
    ...(authHeader ? { Authorization: authHeader } : {}),
    ...options.headers,
  };

  const res = await fetch(endpoint, { ...options, headers });
  const text = await res.text();
  let data;

  try { data = JSON.parse(text); } 
  catch { data = text; }

  if (!res.ok) {
    console.warn(`‚ö†Ô∏è [ghFetch] ${res.status} ${res.statusText}: ${endpoint}`);
    console.warn("Response:", data);
  }

  return data;
}

    
      // detect token: best-effort
      async function detectToken(token){
        try{
          const r = await ghFetch(token, '/user');
          const scopes = r.headers ? (r.headers.get('x-oauth-scopes') || r.headers.get('X-Oauth-Scopes') || '') : '';
          if (r.ok) {
            return { type: 'user_token_or_PAT', user: r.data.login, scopes: scopes.split(',').map(s=>s.trim()).filter(Boolean) };
          }
          if (r.status === 401) return { type: 'invalid', status: 401 };
          // fallback: check rate limit
          const rl = await ghFetch(token, '/rate_limit');
          return { type: 'unknown', status: r.status, root: r.data, rate: rl.data };
        }catch(e){ return { type:'error', message: e.message }; }
      }
    
      // create repo (public) for authenticated user; if exists, continue
      async function createRepoIfNotExists(token, name){
        // try create
        const body = { name, private: false, auto_init: true, description: "run-vps repo created by script" };
        const r = await ghFetch(token, '/user/repos', { method: 'POST', body: JSON.stringify(body), headers: { 'Content-Type':'application/json' }});
        if (r.ok) return r.data;
        // if already exists, try to fetch repo
        if (r.status === 422) {
          // repo exists (maybe), fetch
          // need owner
          const u = await ghFetch(token, '/user');
          if (!u.ok) throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c user ƒë·ªÉ x√°c ƒë·ªãnh owner.');
          const owner = u.data.login;
          const fetchRepo = await ghFetch(token, `/repos/${owner}/${name}`);
          if (fetchRepo.ok) return fetchRepo.data;
          throw new Error('Repo c√≥ v·∫ª t·ªìn t·∫°i nh∆∞ng kh√¥ng truy xu·∫•t ƒë∆∞·ª£c: ' + JSON.stringify(r.data));
        }
        throw new Error(`T·∫°o repo l·ªói: ${r.status} ${JSON.stringify(r.data)}`);
      }
    
      // create/update file in repo
      async function createOrUpdateFile(token, owner, repo, path, contentText, commitMessage = 'Add '+path){
        // get existing
        const get = await ghFetch(token, `/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`);
        let sha = null;
        if (get.ok && get.data && get.data.sha) sha = get.data.sha;
        const body = { message: commitMessage, content: b64EncodeUnicode(contentText) };
        if (sha) body.sha = sha;
        const put = await ghFetch(token, `/repos/${owner}/${repo}/contents/${encodeURIComponent(path)}`, { method: 'PUT', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(body) });
        if (!put.ok) throw new Error(`T·∫°o/c·∫≠p nh·∫≠t file ${path} l·ªói: ${put.status} ${JSON.stringify(put.data)}`);
        return put.data;
      }
    
      // create secret (encrypt with repo public key)
      async function createOrUpdateSecret(token, owner, repo, secretName, secretValue){
        const pk = await ghFetch(token, `/repos/${owner}/${repo}/actions/secrets/public-key`);
        if (!pk.ok) throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c public key c·ªßa repo: ' + JSON.stringify(pk.data));
        await loadSodium();
        const sodium = window.sodium;
        const bpub = sodium.from_base64(pk.data.key, sodium.base64_variants.ORIGINAL);
        const bsec = sodium.from_string(String(secretValue));
        const sealed = sodium.crypto_box_seal(bsec, bpub);
        const encrypted_value = sodium.to_base64(sealed, sodium.base64_variants.ORIGINAL);
        const put = await ghFetch(token, `/repos/${owner}/${repo}/actions/secrets/${encodeURIComponent(secretName)}`, {
          method: 'PUT',
          headers: { 'Content-Type':'application/json' },
          body: JSON.stringify({ encrypted_value, key_id: pk.data.key_id })
        });
        if (!put.ok) throw new Error('T·∫°o secret l·ªói: ' + JSON.stringify(put.data));
        return true;
      }
    
      // ensure workflow has permissions block (insert at top if missing)
      function ensurePermissionsAndDispatch(workflowText){
        // If it already contains "permissions:" with contents/actions both, keep it.
        const hasPermissions = /permissions:\s*([\s\S]*?)\n(?=\S)/m.test(workflowText) || /permissions:\s*$/m.test(workflowText);
        if (hasPermissions){
          // naive check for both keys
          const hasContents = /contents:\s*write/.test(workflowText);
          const hasActions = /actions:\s*write/.test(workflowText);
          if (hasContents && hasActions) return workflowText;
          // add or replace minimal block after 'on:' or at top
        }
        // Prepend permissions block at top
        const permBlock = `permissions:\n  contents: write\n  actions: write\n\n`;
        return permBlock + workflowText;
      }
    
      // fetch external workflow; if fail, return default sample content (safe)
      async function fetchWorkflowOrDefault(url, defaultContent){
        try{
          const r = await fetch(url);
          if (!r.ok) throw new Error('Fetch fail '+r.status);
          const txt = await r.text();
          if (!txt || txt.trim().length === 0) throw new Error('Empty content');
          return txt;
        }catch(e){
          console.warn('Kh√¥ng l·∫•y ƒë∆∞·ª£c t·ª´ URL, d√πng n·ªôi dung m·∫∑c ƒë·ªãnh.', e);
          return defaultContent;
        }
      }
    
      // trigger workflow dispatch by filename
      async function triggerWorkflow(token, owner, repo, workflowFileName, ref='main', inputs={}){
        const r = await ghFetch(token, `/repos/${owner}/${repo}/actions/workflows/${encodeURIComponent(workflowFileName)}/dispatches`, {
          method: 'POST',
          headers: { 'Content-Type':'application/json' },
          body: JSON.stringify({ ref, inputs })
        });
        if (r.status === 204) return true;
        // sometimes workflow id numeric required; try list and match
        const list = await ghFetch(token, `/repos/${owner}/${repo}/actions/workflows`);
        if (list.ok && list.data && list.data.workflows){
          const wf = list.data.workflows.find(w=>w.path && w.path.endsWith('/'+workflowFileName));
          if (wf){
            const r2 = await ghFetch(token, `/repos/${owner}/${repo}/actions/workflows/${wf.id}/dispatches`, { method:'POST', headers:{ 'Content-Type':'application/json' }, body: JSON.stringify({ ref, inputs })});
            if (r2.status === 204) return true;
          }
        }
        throw new Error('Kh√¥ng th·ªÉ dispatch workflow: ' + JSON.stringify(r.data));
      }

async function getUserName(token) {
  const data = await ghFetch("/user", token);
  return data.login;
}

        async function waitForFile(token, owner, repo, path, interval = 5000, timeout = 60000) {
          if (!owner) owner = await getUserName(token);
          const authHeader = getAuthHeader(token);
          const start = Date.now();
        
          console.log(`üöÄ ƒêang ch·ªù file "${path}" trong repo ${owner}/${repo}...`);
        
          while (Date.now() - start < timeout) {
            try {
              const res = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
                headers: {
                  Accept: "application/vnd.github+json",
                  ...authHeader
                }
              });
        
              if (res.ok) {
                console.log(`‚úÖ File ${path} ƒë√£ xu·∫•t hi·ªán trong repo ${repo}!`);
                return true;
              } else if (res.status === 404) {
                console.log(`‚è≥ Ch∆∞a th·∫•y file ${path}, ch·ªù th√™m ${interval / 1000}s...`);
                await new Promise(r => setTimeout(r, interval));
              } else {
                console.warn(`‚ö†Ô∏è API l·ªói ${res.status}: ${res.statusText}`);
                break;
              }
            } catch (e) {
              console.error("üí• L·ªói fetch:", e);
              break;
            }
          }
        
          console.warn(`‚ùå Qu√° ${timeout / 1000}s r·ªìi m√† file ${path} v·∫´n ch∆∞a c√≥.`);
          return false;
        }

      // MAIN: integrate with form in your page
      document.getElementById('vpsForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        const token = document.getElementById('githubToken').value.trim();
        const createBtn = document.getElementById('createBtn');
        const originalBtnText = createBtn.innerHTML;
        if(!token){ showStatus('Vui l√≤ng nh·∫≠p GitHub Token!', 'error'); return; }
    
        try{
          createBtn.disabled = true;
          createBtn.innerHTML = '<span class="loading-spinner"></span>ƒêang t·∫°o VPS...';
          showStatus('ƒêang ki·ªÉm tra token...', 'info');
    
          const det = await detectToken(token);
          console.log('detectToken:', det);
          if (det.type === 'invalid') { showStatus('Token kh√¥ng h·ª£p l·ªá ho·∫∑c h·∫øt h·∫°n (401).', 'error'); throw new Error('Token invalid'); }
          showStatus(`Token OK. user=${det.user||det.user||det.user||'unknown'}, scopes=${(det.scopes||[]).join(', ') || '(unknown)'}`, 'success');
    
          // get owner (authenticated user)
          const who = await ghFetch(token, '/user');
          if (!who.ok) throw new Error('Kh√¥ng l·∫•y ƒë∆∞·ª£c user info: ' + JSON.stringify(who.data));
          const owner = who.data.login;
    
          showStatus('T·∫°o repo run-vps (public)...', 'info');
          const repoData = await (async ()=>{
            try{
              return await createRepoIfNotExists(token, 'run-vps');
            }catch(err){
              // if error but repo exists, try fetch
              if (err.message && err.message.includes('exists')) {
                const r = await ghFetch(token, `/repos/${owner}/run-vps`);
                if (r.ok) return r.data;
              }
              throw err;
            }
          })();
          console.log('repoData', repoData);
          showStatus('Repo ready: ' + (repoData.html_url || 'run-vps'), 'success');
    
          // random 5-digit
          const randPass = Math.floor(10000 + Math.random()*90000).toString();
          showStatus('T·∫°o secret MY_PASSWORD (ƒëang m√£ ho√°)...', 'info');
          await createOrUpdateSecret(token, owner, 'run-vps', 'MY_PASSWORD', randPass);
          showStatus('Secret MY_PASSWORD ƒë√£ t·∫°o üîê', 'success');
    
          // Ask user for URLs (prompt) ‚Äî you can paste your own URLs; if left blank, use built-in safe defaults
          const deleteURL = prompt('Nh·∫≠p URL raw cho delete.yml (ƒë·ªÉ tr·ªëng ƒë·ªÉ d√πng m·∫´u an to√†n):', '');
          const vpsURL = prompt('Nh·∫≠p URL raw cho VPS_github.yml (ƒë·ªÉ tr·ªëng ƒë·ªÉ d√πng m·∫´u an to√†n):', '');
    
          // default safe workflows (m·∫´u) ‚Äî non-destructive, demo only
          const defaultDelete = await fetch("workflow/2.txt").text();
          const defaultVPS = await fetch("workflow/1.txt").text();
    
          showStatus('L·∫•y n·ªôi dung workflow t·ª´ URL (ho·∫∑c d√πng m·∫´u)...', 'info');
          const delTxt = ensurePermissionsAndDispatch(await fetchWorkflowOrDefault(deleteURL, defaultDelete));
          const vpsTxt = ensurePermissionsAndDispatch(await fetchWorkflowOrDefault(vpsURL, defaultVPS));
    
          showStatus('Upload workflow files...', 'info');
          await createOrUpdateFile(token, owner, 'run-vps', '.github/workflows/delete.yml', delTxt, 'Add delete workflow');
          await createOrUpdateFile(token, owner, 'run-vps', '.github/workflows/VPS_github.yml', vpsTxt, 'Add VPS_github workflow');
          showStatus('Workflow uploaded ‚úÖ', 'success');
    
// Trigger VPS_github workflow
showStatus('G·ª≠i request ch·∫°y workflow VPS_github.yml...', 'info');
await triggerWorkflow(token, owner, 'run-vps', 'VPS_github.yml', 'main', {});
showStatus('Workflow VPS_github ƒë√£ ƒë∆∞·ª£c dispatch üöÄ', 'success');

// Ch·ªù file RDP xu·∫•t hi·ªán
showStatus('ƒêang ch·ªù file RDP xu·∫•t hi·ªán...', 'info');
const repo = 'run-vps';
const path = 'rdp-connection.rdp';
const fileReady = await waitForFile(token, null, repo, path, 7000, 180000);

if (fileReady) {
  const username = await getUserName(token);
  const rdpUrl = `https://raw.githubusercontent.com/${username}/${repo}/main/${path}`;
  showVpsinfo(rdpUrl, randPass, username);
  showStatus('VPS ƒë√£ s·∫µn s√†ng üéâ', 'success');
} else {
  showStatus('Kh√¥ng th·∫•y file RDP sau th·ªùi gian ch·ªù üòî', 'error');
}
    
        }catch(err){
          console.error(err);
          showStatus('L·ªói: ' + (err.message || String(err)), 'error');
        }finally{
          createBtn.disabled = false;
          createBtn.innerHTML = originalBtnText;
        }
      });
    
      // focus input
      document.getElementById('githubToken').focus();
    
    })();
    </script>
</body>
</html>